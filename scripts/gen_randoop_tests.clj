#!/usr/bin/env bb

(require '[clojure.java.shell :refer [sh]]
         '[cheshire.core :as json]
         '[clojure.string :as str])

(defn execute-commands [work-dir commands]
  ;; Iterate over each command and execute it within the working directory

  (let [last-command-successful (atom true)]
    (doseq [cmd commands]
      (cond
              ;; Custom check for the placeholder command
        (= cmd "<CHECK-IF-MUTATION-IS-BUGGY>")
        (println (if @last-command-successful
                   "NO FAILING UNIT TEST IS GENERATED BY RANDOOP"
                   "FAILING UNIT TEST IS GENERATED BY RANDOOP"))
        :else
        (do
          (println "Executing in directory:" work-dir "\nCommand:" cmd)
          (let [result (sh "bash" "-c" (str "source scripts/env" " && " "cd " work-dir " && " cmd))]
            (println "stdout:" (:out result))
            (println "stderr:" (:err result))
            (reset! last-command-successful (= 0 (:exit result)))
            (when (not= 0 (:exit result))
              (println "Error:" (:exit result) "while executing command:" cmd)
              (when (not (str/starts-with? cmd "mvn test"))
                (throw (ex-info "Command execution failed" {:exit-code (:exit result)})))))))
      (println "==============================="))))
;; Assuming the JSON file is named config.json and located in the scripts directory
(let [json-content (slurp "scripts/config.json")
      config       (json/parse-string json-content true)
      mutations    (:mutations config)]

  ;; Iterate over each mutation
  (doseq [mutation mutations]
    (execute-commands (:directory mutation) (:commands mutation))))