#!/usr/bin/env bb

(require '[clojure.java.shell :refer [sh]]
         '[cheshire.core :as json]
         '[clojure.string :as str])

(defn append-to-log [message]
  (spit "scripts/log.txt" message :append true))

(defn execute-commands [work-dir commands id]
  ;; Iterate over each command and execute it within the working directory

  (let [last-command-successful (atom true)]
    (doseq [raw-command commands]
      (let [command (str/replace raw-command "<ID>" id)]
        (cond
          (= command "<CHECK-IF-MUTATION-IS-BUGGY>")
          (let [log-message (str id ": " (if @last-command-successful
                                           "NO FAILING UNIT TEST IS GENERATED BY RANDOOP\n"
                                           "FAILING UNIT TEST IS GENERATED BY RANDOOP\n"))]
            (append-to-log log-message))

          :else
          (do
            (println "Executing in directory:" work-dir "\nCommand:" command)
            (let [result (sh "bash" "-c" (str "source scripts/env" " && " "cd " work-dir " && " command))]
              (println "stdout:" (:out result))
              (println "stderr:" (:err result))
              (reset! last-command-successful (= 0 (:exit result)))
              (when (not= 0 (:exit result))
                (println "Error:" (:exit result) "while executing command:" command)
                (when (not (str/starts-with? command "mvn test"))
                  (throw (ex-info "Command execution failed" {:exit-code (:exit result)}))))))))
      (println "==============================="))))
;; Assuming the JSON file is named config.json and located in the scripts directory
(let [json-content (slurp "scripts/config.json")
      config       (json/parse-string json-content true)
      mutations    (:mutations config)]
  ;; Iterate over each mutation
  (doseq [mutation mutations]
    (execute-commands (:directory mutation)
                      (:commands mutation)
                      (:id mutation))))